(defun pretty-print (table)
  (let ((rows (if (listp table) table (list table))))
    (if (null rows)
        (format t "Input table is empty!~%")
        (let ((colums '()))
          (maphash (lambda (key value)
                     (declare (ignore value))
                     (push key colums))
                   (first rows))
          (setf colums (nreverse colums))
          (format t "~%")
          (dolist (colum colums) (format t "~15A" colum))
          (format t "~%")
          (dolist (colum colums)
            (declare (ignore colum))
            (format t "---------------"))
          (format t "~%")

          (dolist (row rows)
            (dolist (col colums)
              (format t "~15a" (gethash col row)))
            (format t "~%"))))
    t))

(defun company-record (line)
  (let ((ht (make-hash-table :test 'equal)))
    (setf (gethash :id ht) (parse-integer (first line)))
    (setf (gethash :name ht) (second line))
    (setf (gethash :country ht) (third line))
    (setf (gethash :founder ht) (cadddr line))
    ht))

(defun spacecraft-record (line)
  (let ((ht (make-hash-table :test 'equal)))
    (setf (gethash :id ht) (parse-integer (first line)))
    (setf (gethash :name ht) (second line))
    (setf (gethash :type ht) (third line))
    (setf (gethash :company-id ht) (parse-integer (cadddr line)))))

(defun read-csv (file-hash file-type)
  (let ((ht (make-hash-table :test 'equal)))
  (with-open-file (stream file-hash)
    (do ((line (read-line stream nil) (read-line stream nil)))
        ((null line) ht)
      (let* ((clean-line (string-trim '(#\Space #\Tab #\Return #\Newline) line))
             (breaking (uiop:split-string clean-line :separator ","))
             (record (case file-type
                       (:companies (company-record breaking))
                       (:spacecrafts (spacecraft-record breaking))))
             (record-id (gethash :id record)))
        (setf (gethash record-id ht) record))))

    (lambda (&rest key)
      (let ((result-rows '()))
        (cond
          ((or (null key) (and (= (length key) 2) (getf key :test)))
           (maphash (lambda (key value)
                      (declare (ignore key))
                      (push value result-rows))
                    ht))
          ((getf key :id)
           (let ((rec (gethash (getf key :id) ht)))
             (when rec
               (push rec result-rows))))
          (t
           (let ((search-key (first key))
                 (search-val (second key)))
             (maphash (lambda (key value)
                        (declare (ignore key))
                        (if (equal (gethash search-key value) search-val)
                            (push value result-rows)))
                      ht))))
        (setf result-rows  (nreverse result-rows))

        (if (getf key :test)
            result-rows
            (pretty-print result-rows))))))
      
(funcall (read-csv "c:/Users/LoPHarp/portacle/Lisp_5/companies.csv" :companies))

(defun modul-test-companies ()
  (let* ((ht (read-csv "c:/Users/LoPHarp/portacle/Lisp_5/companies.csv" :companies))
         (data1 (funcall ht :test t))
         (data2 (funcall ht :id 1 :test t))
         (data3 (funcall ht :name "ESA" :test t)))
    (if (= (length data1) 5)
        (format t "TEST 1 : TRUE TEST~%")
        (format t "TEST 1 : FALSE TEST~%"))
    (if (and data2 (= (gethash :id data2) 1))
        (format t "TEST 2 : TRUE TEST~%")
        (format t "TEST 2 : FALSE TEST~%"))
    (if (and data3 (equal (gethash :name (first data3)) "ESA"))
        (format t "TEST 3 : TRUE TEST~%")
        (format t "TEST 3 : FALSE TEST~%"))))
         
