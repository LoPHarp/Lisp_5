(defun pretty-print (table)
  (let ((rows (if (listp table) table (list table))))
    (if (null rows)
        (format t "Input table\string is empty!~%")
        (let ((colums '()))
          (maphash (lambda (key value)
                     (declare (ignore value))
                     (push key colums))
                   (first rows))
          (setf colums (nreverse colums))
          (format t "~%")
          (dolist (colum colums) (format t "~15A" colum))
          (format t "~%")
          (dolist (colum colums)
            (declare (ignore colum))
            (format t "---------------"))
          (format t "~%")

          (dolist (row rows)
            (dolist (col colums)
              (format t "~15a" (gethash col row)))
            (format t "~%"))))
    t))

(defun save-to-file (file-path records)
  (with-open-file (stream file-path :direction :output :if-exists :supersede)
    (when records
      (let ((keys '()))
        (maphash (lambda (key value)
                   (declare (ignore value))
                   (push key keys))
                 (first records))
        (setf keys (nreverse keys))
        
        (format stream "~a" (first keys))
        (dolist (key (cdr keys))
          (format stream ",~a" key))
        (format stream "~%")

        (dolist (row records)
          (let ((values '()))
            (dolist (key keys)
              (push (gethash key row) values))
            (setf values (nreverse values))

            (format stream "~a" (first values))
            (dolist (value (cdr values))
              (format stream ",~a" value))
            (format stream "~%"))))))
  file-path)

(defun company-record (line)
  (let ((ht (make-hash-table :test 'equal)))
    (setf (gethash :id ht) (parse-integer (first line)))
    (setf (gethash :name ht) (second line))
    (setf (gethash :country ht) (third line))
    (setf (gethash :founder ht) (cadddr line))
    ht))

(defun spacecraft-record (line)
  (let ((ht (make-hash-table :test 'equal)))
    (setf (gethash :id ht) (parse-integer (first line)))
    (setf (gethash :name ht) (second line))
    (setf (gethash :type ht) (third line))
    (setf (gethash :company-id ht) (parse-integer (cadddr line)))
    ht))

(defun select (file-hash file-type)
  (let ((ht (make-hash-table :test 'equal)))
  (with-open-file (stream file-hash)
    (do ((line (read-line stream nil) (read-line stream nil)))
        ((null line) ht)
      (let* ((clean-line (string-trim '(#\Space #\Tab #\Return #\Newline) line))
             (breaking (uiop:split-string clean-line :separator ","))
             (record (case file-type
                       (:companies (company-record breaking))
                       (:spacecrafts (spacecraft-record breaking))))
             (record-id (gethash :id record)))
        (setf (gethash record-id ht) record))))

    (lambda (&rest keys)
      (let* ((save-path (getf keys :save))
             (test-mode (getf keys :test))
             (query-keys (copy-list keys))
             (result-rows '()))
        
        (remf query-keys :save)
        (remf query-keys :test)

        (cond
          ((null query-keys)
           (maphash (lambda (key value)
                      (declare (ignore key))
                      (push value result-rows))
                    ht))
          ((getf query-keys :id)
           (let ((record (gethash (getf query-keys :id) ht)))
             (when record (push record result-rows))))
          (t
           (let ((search-key (first query-keys))
                 (search-value (second query-keys)))
             (maphash (lambda (key row-ht)
                        (declare (ignore key))
                        (when (equal (gethash search-key row-ht) search-value)
                          (push row-ht result-rows)))
                      ht))))
        (setf result-rows  (nreverse result-rows))

        (when save-path
          (let ((actual-path (if (eq save-path t) "output.csv" save-path)))
            (save-to-file actual-path result-rows)
            (format t "Save ~a records to ~a~%" (length result-rows) actual-path)))

        (if test-mode
            result-rows
            (pretty-print result-rows))))))
         
(defun modul-test ()
  (let* ((ht (select "c:/Users/dmanu/portacle/Lisp_5/companies.csv" :companies))
         (data1 (funcall ht :test t))
         (data2 (funcall ht :id 1 :test t))
         (data3 (funcall ht :name "ESA" :test t)))
    (format t "Tests with the file companies.csv~%")
    (if (= (length data1) 5)
        (format t "TEST 1 : TRUE TEST~%")
        (format t "TEST 1 : FALSE TEST~%"))
    (if (and data2 (= (gethash :id (first data2)) 1))
        (format t "TEST 2 : TRUE TEST~%")
        (format t "TEST 2 : FALSE TEST~%"))
    (if (and data3 (equal (gethash :name (first data3)) "ESA"))
        (format t "TEST 3 : TRUE TEST~%")
        (format t "TEST 3 : FALSE TEST~%")))
  
  (let* ((ht (select "c:/Users/dmanu/portacle/Lisp_5/spacecrafts.csv" :spacecrafts))
         (data1 (funcall ht :test t))
         (data2 (funcall ht :id 1 :test t))
         (data3 (funcall ht :name "Starship" :test t)))
    (format t "Tests with the file spacecrafts.csv~%")
    (if (= (length data1) 7)
        (format t "TEST 1 : TRUE TEST~%")
        (format t "TEST 1 : FALSE TEST~%"))
    (if (and data2 (= (gethash :id (first data2)) 1) (= (gethash :company-id (first data2)) 1))
        (format t "TEST 2 : TRUE TEST~%")
        (format t "TEST 2 : FALSE TEST~%"))
    (if (and data3 (equal (gethash :name (first data3)) "Starship")
                          (equal (gethash :type (first data3)) "Rocket")
                          (= (gethash :company-id (first data3)) 1))
        (format t "TEST 3 : TRUE TEST~%")
        (format t "TEST 3 : FALSE TEST~%"))))
         
